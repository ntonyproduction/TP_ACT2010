#pour voir si on aurait pu la remplacer par un x ou est-ce que la position matricielle (2,2) aurait pu etre un x?
rrr=eacf(diff(log(ttaux)))
rrr$eacf[1,2]
library('TSA')
library('tseries')
######## importation et traitement primaire du jeu de donnees ###########
#importation du jeu de donnees
taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv")
#taux <- read.csv2("C:/Users/Yanic/ulaval/Séries chronologiques/tp/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
#on transforme en time serie
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
######### premiere analyse de la serie grace a son graphique et a sa fonction d'autocorrelation ##########
#on trace le graphique
win.graph(height=4,width=6)
plot(ttaux,ylab='taux de change', type='o', xlab='année', main='Taux de change ')
#on observe difficilement de stationnarité,
#forte aurocorrelation, decroissance tres lente avec l'augmentation
#on ne donc pas une fonction ARMA(p,1,q) ni ARMA(p,2,q)
acf(ttaux, main='autocorrélation')
pacf(ttaux, main='autocorrélation')
######### on verifie si une transformation est appropriee ######
BoxCox.ar(ttaux)
BoxCox.ar(ttaux)$mle
BoxCox.ar(ttaux)$ci
#logiquement et avec nos acquis de gestion du risque financier, on sait qu'il est plus logique d'observer le rendement
#d'un titre financier (ou d'un taux de change). C'est donc sans surprise qu'on trouve un lambda de 0 qui nous suggere d'utiliser
#le logarithme de notre serie chronologique comme transformation. On s'attend egalement a avoir a differencier une seul fois
#pour retrouve le rendement de notre taux de change
#le rendement permet de comparer deux produits fianciers ayant des valeurs differentes entres eux
plot(as.vector(log(ttaux)), type='o', ylab='logarithme du taux')
#avec une premiere differenciation
plot(as.vector(diff(log(ttaux))), type='o', ylab='différencitation du logarithme')
#la premiere differenciation semble plutot stable
#premiere observation de l'autocorrelation et de l'autocorrelation partielle suite a la transformation
acf(log(ttaux))
#on observe encore assez bien la non stationnarite (forte autocorrelation, decroissance lente)
#ce qui est normal puisque notre transformation n'a pas pour but de stationnarise la serie
#mais bien de la?
pacf(log(ttaux))
#AR de degres 2 fortement suggere ce qu'on retrouve par apres dans le test ADF
######### tests de stationnarite ########
#test ADF pour la stationnarite
#on trouve d'abord la valeur de l'ordre AR(k) suggere par R
ar(log(ttaux))
#R suggere d'utiliser k=2
adf.test(log(ttaux), k=2)
#suggere la non stationnarite avec une p value de 93% (tres pres detre stationnaire)
#on tente une premiere differenciation
ar(diff(log(ttaux)))
#R suggere k=1
adf.test(diff(log(ttaux)),k=1)
#suggere treeees fortement la stationnarite avec une p value inferieur a 1%
#on garde la premiere differenciation
######## on cherche le modele de notre serie maintenant stationnaire ############
#autocorrelation et autocorrelation partielle
acf(diff(log(ttaux)))
#WTF IS A LAG DE 0.1 (echelle du graphique sortie)? Réponse: Diviser en mois.
#On semble avoir un modele AR(1) pour la partie autoregressive
#On semble meme pouvoir ignorer la partie MA puisque l'autocorrelation est tres faible apres?
#(aller demander au prof pourquoi la conclusion de MA(0) a la page 88 du chap6 parce qu'on a ici la meme conclusion)
pacf(diff(log(ttaux)))
#On semble avoir un modele MA(1) pour la partie MA, est-ce possible de le retirer?
#qu'est ce que eacf en pense?
eacf(diff(log(ttaux)))
#eacf semble hesitant entre ARMA(0,1) et ARMA(1,1) pour la premiere diff du log
#on serait tenter de choisir un ARMA(0,1) ce qui corroborerait les test d'autocorrelation et d'autocorrelation partiel
#on peut regarder la valeur de rho 0,2 du tableau (la position matricielle (1,2))
#pour voir si on aurait pu la remplacer par un x ou est-ce que la position matricielle (2,2) aurait pu etre un x?
rrr=eacf(diff(log(ttaux)))
rrr$eacf[1,2]
######## importation et traitement primaire du jeu de donnees ###########
#importation du jeu de donnees
taux <- read.csv2("C:/Users/ANGAG426/Desktop/TP_ACT2010/Taux_de_change_US_Euro.csv")
#taux <- read.csv2("C:/Users/Yanic/ulaval/Séries chronologiques/tp/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
#on transforme en time serie
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
######### premiere analyse de la serie grace a son graphique et a sa fonction d'autocorrelation ##########
#on trace le graphique
win.graph(height=4,width=6)
plot(ttaux,ylab='taux de change', type='o', xlab='année', main='Taux de change ')
#on observe difficilement de stationnarité,
#forte aurocorrelation, decroissance tres lente avec l'augmentation
#on ne donc pas une fonction ARMA(p,1,q) ni ARMA(p,2,q)
acf(ttaux, main='autocorrélation')
pacf(ttaux, main='autocorrélation')
######### on verifie si une transformation est appropriee ######
BoxCox.ar(ttaux)
BoxCox.ar(ttaux)$mle
BoxCox.ar(ttaux)$ci
#logiquement et avec nos acquis de gestion du risque financier, on sait qu'il est plus logique d'observer le rendement
#d'un titre financier (ou d'un taux de change). C'est donc sans surprise qu'on trouve un lambda de 0 qui nous suggere d'utiliser
#le logarithme de notre serie chronologique comme transformation. On s'attend egalement a avoir a differencier une seul fois
#pour retrouve le rendement de notre taux de change
#le rendement permet de comparer deux produits fianciers ayant des valeurs differentes entres eux
plot(as.vector(log(ttaux)), type='o', ylab='logarithme du taux')
#avec une premiere differenciation
plot(as.vector(diff(log(ttaux))), type='o', ylab='différencitation du logarithme')
#la premiere differenciation semble plutot stable
#premiere observation de l'autocorrelation et de l'autocorrelation partielle suite a la transformation
acf(log(ttaux))
#on observe encore assez bien la non stationnarite (forte autocorrelation, decroissance lente)
#ce qui est normal puisque notre transformation n'a pas pour but de stationnarise la serie
#mais bien de la?
pacf(log(ttaux))
#AR de degres 2 fortement suggere ce qu'on retrouve par apres dans le test ADF
######### tests de stationnarite ########
#test ADF pour la stationnarite
#on trouve d'abord la valeur de l'ordre AR(k) suggere par R
ar(log(ttaux))
#R suggere d'utiliser k=2
adf.test(log(ttaux), k=2)
#suggere la non stationnarite avec une p value de 93% (tres pres detre stationnaire)
#on tente une premiere differenciation
ar(diff(log(ttaux)))
#R suggere k=1
adf.test(diff(log(ttaux)),k=1)
#suggere treeees fortement la stationnarite avec une p value inferieur a 1%
#on garde la premiere differenciation
######## on cherche le modele de notre serie maintenant stationnaire ############
#autocorrelation et autocorrelation partielle
acf(diff(log(ttaux)))
#WTF IS A LAG DE 0.1 (echelle du graphique sortie)? Réponse: Diviser en mois.
#On semble avoir un modele AR(1) pour la partie autoregressive
#On semble meme pouvoir ignorer la partie MA puisque l'autocorrelation est tres faible apres?
#(aller demander au prof pourquoi la conclusion de MA(0) a la page 88 du chap6 parce qu'on a ici la meme conclusion)
pacf(diff(log(ttaux)))
#On semble avoir un modele MA(1) pour la partie MA, est-ce possible de le retirer?
#qu'est ce que eacf en pense?
eacf(diff(log(ttaux)))
#eacf semble hesitant entre ARMA(0,1) et ARMA(1,1) pour la premiere diff du log
#on serait tenter de choisir un ARMA(0,1) ce qui corroborerait les test d'autocorrelation et d'autocorrelation partiel
#on peut regarder la valeur de rho 0,2 du tableau (la position matricielle (1,2))
#pour voir si on aurait pu la remplacer par un x ou est-ce que la position matricielle (2,2) aurait pu etre un x?
rrr=eacf(diff(log(ttaux)))
rrr$eacf[1,2]
plot(armasubsets(y=diff(log(ttaux)), nar=3, nma=3, y.name='test',ar.method='ols'))
ttaux110 <- arima(log(ttaux), order=c(1,1,0), method='ML')
ttaux110
mean(ttaux)
mean(log(ttaux))
mean(log(diff(ttaux)))
?diff
mean(diff(log(ttaux)))
exp(mean(diff(log(ttaux))))
taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
ttaux.adf<-adf.test(ttaux, k=ar(ttaux)$order)
library('TSA')
library('TSA')
library('tseries')
library('forcast')
install.packages("forecast")
round(ttaux.adf$p.value,4)
ttaux.adf <- adf.test(ttaux, k=ar(ttaux)$order)
round(ttaux.adf$p.value,4)*100
boxcoxv <- BoxCox.ar(ttaux)$mle
boxcoxic <- BoxCox.ar(ttaux)$ci
BoxCox.ar(ttaux)
taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
plot(ttaux,ylab='taux de change', type='o', xlab='année', main='Taux de change ')
acf(ttaux, main='autocorrélation')
pacf(ttaux, main='autocorrélation')
BoxCox.ar(ttaux)
BoxCox.ar(ttaux)$mle
BoxCox.ar(ttaux)$ci
ttaux.log.adf<-adf.test(diff(log(ttaux)), k=ar(diff(log(ttaux)))$order)
acf(log(ttaux))
adf.test(log(ttaux), k=2)
ttaux.log.adf <- adf.test(diff(log(ttaux)), k=ar(diff(log(ttaux)))$order)
round(ttaux.log.adf$p.value,4)*100
ttaux011 <- arima(log(ttaux), order=c(0,1,1), method='ML')
ttaux110 <- arima(log(ttaux), order=c(1,1,0), method='ML')
ttaux111 <- arima(log(ttaux), order=c(1,1,1), method='ML')
ttaux.log.mu <- mean(diff(log(ttaux)))
ttaux011
ttaux111
ttaux011.sw <- shapiro.test(rstandard(ttaux011))
ttaux110.sw <- shapiro.test(rstandard(ttaux110))
ttaux111.sw <- shapiro.test(rstandard(ttaux111))
ttaux111.sw
rstandard(ttaux110)
1-pnorm(2)
ttaux.log.adf <- adf.test(diff(log(ttaux)), k=ar(diff(log(ttaux)))$order)
ttaux110.rt <- runs(residuals(ttaux011))$pvalue
ttaux011.rt <- runs(residuals(ttaux110))$pvalue
ttaux111.rt <- runs(residuals(ttaux111))$pvalue
ttaux111.rt
ttaux011.rt
saaq <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/SAAQ-2015.csv")
View(saaq)
naadc<-ts(saaq$NAADC,start=c(saaq$Année[1],1),end=c(saaq$Année[length(saaq$Année)],1), frequency=1)
npa<-ts(saaq$NPA,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
ndi<-ts(saaq$NDI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
cti<-ts(saaq$CTI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
plot(saaq$NAADC,ylab="nombres d'accidents",type='o')
plot(npa)
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(saaq$NAADC,ylab="nombres d'accidents avec dommages corporels",type='o')
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(ndi, ylab = "Nombre de demandes d'indemnités", type = "o")
plot(cti, ylab = "Coût total de l'indemnisation", type = "o")
plot(npa, ylab = "Nombre de personnes accidentées", type = "o") # pas de stationnarité
plot(ndi, ylab = "Nombre de demandes d'indemnités", type = "o") # pas de stationnarité
plot(cti, ylab = "Coût total de l'indemnisation", type = "o") # pas de stationnarité
acf(npa, main='autocorrélation NAADC')
pacf(npa, main='autocorrélation NAADC')
acf(ndi, main='autocorrélation NDI')
pacf(ndi, main='autocorrélation NDI')
acf(naadc, main='autocorrélation NAADC')
pacf(naadc, main='autocorrélation NAADC')
acf(npa, main='autocorrélation NPA')
######## importation et traitement primaire du jeu de donnees ###########
#importation du jeu de donnees
#taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv") MY BAD J AI EFFACÉ TON REPORTERY
taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
#on transforme en time serie
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
######### premiere analyse de la serie grace a son graphique et a sa fonction d'autocorrelation ##########
#on trace le graphique
plot(ttaux,ylab='taux de change', type='o', xlab='année', main='Taux de change ')
#on observe difficilement de stationnarité,
#forte aurocorrelation, decroissance tres lente avec l'augmentation
#on ne donc pas une fonction ARMA(p,1,q) ni ARMA(p,2,q)
acf(ttaux, main='autocorrélation')
pacf(ttaux, main='autocorrélation')
######### on verifie si une transformation est appropriee ######
BoxCox.ar(ttaux)
BoxCox.ar(ttaux)$mle
BoxCox.ar(ttaux)$ci
#logiquement et avec nos acquis de gestion du risque financier, on sait qu'il est plus logique d'observer le rendement
#d'un titre financier (ou d'un taux de change). C'est donc sans surprise qu'on trouve un lambda de 0 qui nous suggere d'utiliser
#le logarithme de notre serie chronologique comme transformation. On s'attend egalement a avoir a differencier une seul fois
#pour retrouve le rendement de notre taux de change
#le rendement permet de comparer deux produits fianciers ayant des valeurs differentes entres eux
plot(as.vector(log(ttaux)), type='o', ylab='logarithme du taux')
#avec une premiere differenciation
plot(as.vector(diff(log(ttaux))), type='o', ylab='différencitation du logarithme')
#la premiere differenciation semble plutot stable
#premiere observation de l'autocorrelation et de l'autocorrelation partielle suite a la transformation
acf(log(ttaux))
#on observe encore assez bien la non stationnarite (forte autocorrelation, decroissance lente)
#ce qui est normal puisque notre transformation n'a pas pour but de stationnarise la serie
#mais bien de la?
pacf(log(ttaux))
#AR de degres 2 fortement suggere ce qu'on retrouve par apres dans le test ADF
######### tests de stationnarite ########
#test ADF pour la stationnarite
#on trouve d'abord la valeur de l'ordre AR(k) suggere par R
ar(log(ttaux))
adf.test(log(ttaux), k=2)
ar(diff(log(ttaux)))
adf.test(diff(log(ttaux)),k=1)
saaq <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/SAAQ-2015.csv")
#saaq <- read.csv2("C:/Users/TEMP/Desktop/tempo/TP_ACT2010/SAAQ-2015.csv")
#saaq <- read.csv2("C:/Users/Yanic/ulaval/Séries chronologiques/tp/SAAQ-2015.csv")
naadc<-ts(saaq$NAADC,start=c(saaq$Année[1],1),end=c(saaq$Année[length(saaq$Année)],1), frequency=1)
npa<-ts(saaq$NPA,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
ndi<-ts(saaq$NDI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
cti<-ts(saaq$CTI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
#NAADC : Nombre d'accidents avec dommages corporels
#NPA : Nombre de personnes accidentées
#NDI : Nombre de demandes d'indemnités
#CTI : Coût total de l'indemnisation (en millions de dollars, et en dollars constants 2015)
#################################################
#                  NAADC                        #
#################################################
######### premiere analyse de la serie grace a son graphique et a sa fonction d'autocorrelation ##########
#on trace le graphique
plot(saaq$NAADC,ylab="nombres d'accidents avec dommages corporels",type='o')
#on observe difficilement de stationnarité,
#L'autocorrelation décroisse rapidement signe de stationnarité
#L'autocorrelation semble osciller tel un processus autorégressif
#Le pacf semble opter pour un processus AR(1)
acf(naadc, main='autocorrélation NAADC')
pacf(naadc, main='autocorrélation NAADC')
BoxCox.ar(naadc)
BoxCox.ar(naadc)$mle
BoxCox.ar(naadc)$ci
plot(as.vector(naadc^(-2)), type='o')
acf(naadc^(-2))
pacf(naadc^(-2))
ar(naadc^(-2))
adf.test(naadc^(-2), k=2)
ar(naadc)
adf.test(naadc, k=2)
######## importation et traitement primaire du jeu de donnees ###########
#importation du jeu de donnees
#taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv") MY BAD J AI EFFACÉ TON REPORTERY
taux <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/Taux_de_change_US_Euro.csv")
rendement<-taux$US.Euro
anne.mois<-taux$Année.mois
#on transforme en time serie
ttaux<-ts(rendement,start=c(1999,1),end=c(2016,12),frequency = 12)
######### premiere analyse de la serie grace a son graphique et a sa fonction d'autocorrelation ##########
#on trace le graphique
plot(ttaux,ylab='taux de change', type='o', xlab='année', main='Taux de change ')
#on observe difficilement de stationnarité,
#forte aurocorrelation, decroissance tres lente avec l'augmentation
#on ne donc pas une fonction ARMA(p,1,q) ni ARMA(p,2,q)
acf(ttaux, main='autocorrélation')
pacf(ttaux, main='autocorrélation')
######### on verifie si une transformation est appropriee ######
BoxCox.ar(ttaux)
BoxCox.ar(ttaux)$mle
BoxCox.ar(ttaux)$ci
#logiquement et avec nos acquis de gestion du risque financier, on sait qu'il est plus logique d'observer le rendement
#d'un titre financier (ou d'un taux de change). C'est donc sans surprise qu'on trouve un lambda de 0 qui nous suggere d'utiliser
#le logarithme de notre serie chronologique comme transformation. On s'attend egalement a avoir a differencier une seul fois
#pour retrouve le rendement de notre taux de change
#le rendement permet de comparer deux produits fianciers ayant des valeurs differentes entres eux
plot(as.vector(log(ttaux)), type='o', ylab='logarithme du taux')
#avec une premiere differenciation
plot(as.vector(diff(log(ttaux))), type='o', ylab='différencitation du logarithme')
#la premiere differenciation semble plutot stable
#premiere observation de l'autocorrelation et de l'autocorrelation partielle suite a la transformation
acf(log(ttaux))
#on observe encore assez bien la non stationnarite (forte autocorrelation, decroissance lente)
#ce qui est normal puisque notre transformation n'a pas pour but de stationnarise la serie
#mais bien de la?
pacf(log(ttaux))
#AR de degres 2 fortement suggere ce qu'on retrouve par apres dans le test ADF
######### tests de stationnarite ########
#test ADF pour la stationnarite
#on trouve d'abord la valeur de l'ordre AR(k) suggere par R
ar(log(ttaux))
adf.test(log(ttaux), k=2)
ar(diff(log(ttaux)))
adf.test(diff(log(ttaux)),k=1)
ar(log(ttaux))
adf.test(log(ttaux), k=2)
ar(diff(log(ttaux)))
adf.test(diff(log(ttaux)),k=1)
adf.test(log(ttaux), k=2)
adf.test(diff(log(ttaux)),k=1)
saaq <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/SAAQ-2015.csv")
#saaq <- read.csv2("C:/Users/TEMP/Desktop/tempo/TP_ACT2010/SAAQ-2015.csv")
#saaq <- read.csv2("C:/Users/Yanic/ulaval/Séries chronologiques/tp/SAAQ-2015.csv")
naadc<-ts(saaq$NAADC,start=c(saaq$Année[1],1),end=c(saaq$Année[length(saaq$Année)],1), frequency=1)
npa<-ts(saaq$NPA,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
ndi<-ts(saaq$NDI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
cti<-ts(saaq$CTI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
#NAADC : Nombre d'accidents avec dommages corporels
#NPA : Nombre de personnes accidentées
#NDI : Nombre de demandes d'indemnités
#CTI : Coût total de l'indemnisation (en millions de dollars, et en dollars constants 2015)
#################################################
#                  NAADC                        #
#################################################
######### premiere analyse de la serie grace a son graphique et a sa fonction d'autocorrelation ##########
#on trace le graphique
plot(saaq$NAADC,ylab="nombres d'accidents avec dommages corporels",type='o')
#on observe difficilement de stationnarité,
#L'autocorrelation décroisse rapidement signe de stationnarité
#L'autocorrelation semble osciller tel un processus autorégressif
#Le pacf semble opter pour un processus AR(1)
acf(naadc, main='autocorrélation NAADC')
pacf(naadc, main='autocorrélation NAADC')
######### on verifie si une transformation est appropriee ######
#Pourquoi on dit skipper boxcox si il y a stationnarite tandis
#qua la page 85 on fait une transformation meme s'il y a stationnarite?
BoxCox.ar(naadc)
BoxCox.ar(naadc)$mle
BoxCox.ar(naadc)$ci
#boxcox nous propose d'utiliser l'inverse du carre... pourquoi logiquement on voudrait
#analyser avec cette transformation dans le cas d'un nombre d'accident?
#pourquoi l'intervalle ne va pas plus pas que -2?
plot(as.vector(naadc^(-2)), type='o')
#dure a dire pour la stationnarite, les valeurs sont minuscules
acf(naadc^(-2))
pacf(naadc^(-2))
#AR de degree 1 fortement suggere
######### tests de stationnarite ########
###test ADF pour la stationnarite
##naadc^(-2)
#on trouve d'abord la valeur de l'ordre AR(k) suggere par R
ar(naadc^(-2))
adf.test(naadc^(-2), k=2)
plot(saaq$NAADC,ylab="nombres d'accidents avec dommages corporels",type='o')
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
acf(npa, main='autocorrélation NPA')
pacf(npa, main='autocorrélation NPA')
tsoutliers(npa)
install.packages("forcats")
install.packages(c("curl", "quantmod", "Rcpp", "rmarkdown", "stringi"))
install.packages("tsoutliers")
library("tsoutliers")
outliers(ind = npa)
plot.tsoutliers(npa)
tso(npa)
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(ndi, ylab = "Nombre de demandes d'indemnités", type = "o")
tso(ndi) # le test nous propose de retirer les années 1979, 1982 et 1985.
?tso
plot(log(npa), ylab = "Nombre de personnes accidentées", type = "o")
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(log(npa), ylab = "Nombre de personnes accidentées", type = "o")
plot(ndi, ylab = "Nombre de demandes d'indemnités", type = "o")
plot(log(ndi), ylab = "Nombre de demandes d'indemnités", type = "o")
plot(cti, ylab = "Coût total de l'indemnisation", type = "o")
plot(log(cti), ylab = "Coût total de l'indemnisation", type = "o") # logarithme des données
tso(log(npa)) # le test nous propose de retirer les années 1979, 1982 et 1985.
tso(npa)
tso(log(ndi))
tso(ndi) # le test nous propose de retirer l'année 1982
tso(cti) # le test nous propose de retirer l'année 1982
tso(cti) # le test nous propose de retirer l'année 1982
tso(log(cti)) # le test nous propose de retirer l'année 1982
plot(log(npa[-5]))
plot(log(npa[-5]), ylab = "Nombre de personnes accidentées", type = "o")
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(log(npa), ylab = "Nombre de personnes accidentées", type = "o") # logarithme des données
plot(log(npa[-5]), ylab = "Nombre de personnes accidentées", type = "o")
acf(log(npa[-5]), main='autocorrélation NPA')
pacf(log(npa[-5]), main='autocorrélation NPA')
pacf(log(npa[-5]), main='autocorrélation NPA') # propose une AR(1)
BoxCox.ar(log(npa[-5]))
BoxCox.ar(naadc)
library('TSA')
library('tseries')
library("tsoutliers")
BoxCox.ar(log(npa[-5]))
BoxCox.ar(log(npa[-5]))$mle
BoxCox.ar(naadc)
BoxCox.ar(naadc)$mle
BoxCox.ar(log(npa[-5]))
BoxCox.ar(log(npa[-5]))$mle
BoxCox.ar(log(npa[-5]))$ci
plot(log(ndi[-5]), ylab = "Nombre de personnes accidentées", type = "o")
plot(log(ndi), ylab = "Nombre de demandes d'indemnités", type = "o") # logarithme des données
plot(log(ndi[-5]), ylab = "Nombre de personnes accidentées", type = "o")
acf(log(npa[-5]), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(1)
acf(log(ndi[-5]), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(1)
pacf(log(ndi[-5]), main='autocorrélation NPA') # propose une AR(1)
BoxCox.ar(log(ndi[-5]))
BoxCox.ar(log(ndi[-5]))$mle # J'arrive pas plus à un lambda de 0.........
BoxCox.ar(log(ndi[-5]))$ci
plot(log(cti[-5]), ylab = "Nombre de personnes accidentées", type = "o")
plot(log(cti), ylab = "Coût total de l'indemnisation", type = "o") # logarithme des données
plot(log(cti[-5]), ylab = "Nombre de personnes accidentées", type = "o")
acf(log(cti[-5]), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(3), probablement avec une partie AR
pacf(log(cti[-5]), main='autocorrélation NPA') # propose une AR(2)
BoxCox.ar(log(cti[-5]))
BoxCox.ar(log(cti[-5]))$mle
BoxCox.ar(log(cti[-5]))$ci # lambda = 0 est compris dans notre intervalle de confiance, alors il peut être utilisé
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(log(npa), ylab = "Nombre de personnes accidentées", type = "o") # logarithme des données
plot(log(npa[c(-2, -5, -8)]), ylab = "Nombre de personnes accidentées", type = "o")
plot(log(npa), ylab = "Nombre de personnes accidentées", type = "o") # logarithme des données
plot(log(npa[c(-2, -5, -8)]), ylab = "Nombre de personnes accidentées", type = "o")
acf(log(npa[c(-2, -5, -8)]), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(1)
pacf(log(npa[c(-2, -5, -8)]), main='autocorrélation NPA') # propose une AR(1)
BoxCox.ar(log(npa[c(-2, -5, -8)]))
BoxCox.ar(log(npa[c(-2, -5, -8)]))$mle # J'arrive pas plus à un lambda de 0.........
BoxCox.ar(log(npa[c(-2, -5, -8)]))$ci
saaq <- read.csv2("C:/Users/Anthony/Documents/GitHub/TP_ACT2010/SAAQ-2015.csv")
naadc <- ts(saaq$NAADC,start=c(saaq$Année[1],1),end=c(saaq$Année[length(saaq$Année)],1), frequency=1)
npa <- ts(saaq$NPA,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
ndi <- ts(saaq$NDI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
cti <- ts(saaq$CTI,start=saaq$Année[1],end=saaq$Année[length(saaq$Année)])
plot(npa[-5], ylab = "Nombre de personnes accidentées", type = "o")
plot(npa, ylab = "Nombre de personnes accidentées", type = "o")
plot(npa[-5], ylab = "Nombre de personnes accidentées", type = "o")
acf(npa[-5], main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(4) avec partie AR
pacf(npa[-5]), main='autocorrélation NPA') # propose une AR(1)
pacf(npa[-5]), main='autocorrélation NPA') # propose une AR(1)
pacf(npa[-5], main='autocorrélation NPA') # propose une AR(1)
acf(npa[-5], main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(4) avec partie AR
acf(npa[-5], main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(5) avec partie AR
pacf(npa[-5], main='autocorrélation NPA') # propose une AR(1)
BoxCox.ar(npa[-5])
library('TSA')
library('tseries')
library("tsoutliers")
BoxCox.ar(npa[-5])
BoxCox.ar(npa[-5])$mle
BoxCox.ar(npa[-5])$ci
plot(log(npa[-5]), ylab = "Nombre de personnes accidentées", type = "o") # logarithme des données
acf(log(npa[-5]))
plot(as.vector(diff(log(npa[-5]))), type='o', ylab='différencitation du logarithme')
plot(log(npa[-5]), ylab = "Nombre de personnes accidentées", type = "o") # ne semble pas avoir de stationnarité
plot(as.vector(log(npa[-5])), type='o', ylab='logarithme du taux')
plot(diff(log(npa[-5])), type='o', ylab='différencitation du logarithme')
acf(diff(log(npa[-5])), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(5) avec partie AR
pacf(diff(log(npa[-5])), main='autocorrélation NPA') # propose une AR(1)
acf(log(npa[-5]), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(5) avec partie AR
pacf(log(npa[-5]), main='autocorrélation NPA') # propose une AR(1)
acf(log(npa[-5]), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(5) avec partie AR
pacf(log(npa[-5]), main='autocorrélation NPA') # propose une AR(1)
ar(log(npa[-5]))
adf.test(log(npa[-5]), k=2)
ar(diff(log(npa[-5])))
adf.test(diff(log(npa[-5])),k=0)
adf.test(diff(log(npa[-5])),k=0)
acf(diff(log(npa[-5])), main='autocorrélation NPA') # diminue rapidement signe de stationnarité, propose une MA(5) avec partie AR
pacf(diff(log(npa[-5])), main='autocorrélation NPA') # propose une AR(1)
eacf(diff(log(npa[-5])), main='autocorrélation NPA') # propose une AR(1)
eacf(diff(log(npa[-5]))) # propose une AR(1)
